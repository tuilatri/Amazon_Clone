================================================================================
                           CHAPTER 4: IMPLEMENTATION
================================================================================

This chapter presents a comprehensive technical description of the Amazon Clone
e-commerce system implementation. The system integrates a React-based frontend,
a FastAPI backend with PostgreSQL database, and machine learning recommendation
services. Each component is described in detail with relevant code excerpts.

================================================================================
                     4.1 FRONT-END IMPLEMENTATION
================================================================================

The frontend is built using React.js version 18, leveraging functional components
and React Hooks for state management. The application employs React Router for
client-side navigation and Axios for HTTP communication with the backend API.

--------------------------------------------------------------------------------
4.1.1 Application Structure and Routing
--------------------------------------------------------------------------------

The root component (App.js) establishes the application structure by wrapping
all routes within context providers for authentication and account status:

    function App() {
      return (
        <AuthProvider>
          <AccountStatusProvider>
            <AxiosInterceptor>
              <AccountStatusHandler>
                <div className="App">
                  <Routes>
                    <Route path='/' element={<HomePage />} />
                    <Route path='/Product/:category?' element={<Product />} />
                    <Route path='/SignUp' element={<SignUp />} />
                    <Route path='/SignIn' element={<SignIn />} />
                    <Route path='/search' element={<SearchResult />} />
                    <Route path='/Item/:product_id' element={<Item />} />
                    <Route path='/Cart' element={<Cart />} />
                    <Route path='/Checkout' element={<Checkout />} />
                    <Route path='/Orders' element={<Order />} />
                    <Route path='/UserPage' element={<UserPage />} />
                    <Route path='/admin/overview' element={<AdminOverview />} />
                  </Routes>
                </div>
              </AccountStatusHandler>
            </AxiosInterceptor>
          </AccountStatusProvider>
        </AuthProvider>
      );
    }

The nested provider pattern ensures authentication state, account status
monitoring, and HTTP interceptors are available throughout the component tree.

--------------------------------------------------------------------------------
4.1.2 Authentication Context
--------------------------------------------------------------------------------

Authentication state is managed through React Context (AuthContext.js),
providing a centralized store for user session data with localStorage
persistence:

    const AuthContext = createContext();

    export const AuthProvider = ({ children }) => {
        const [isAuthenticated, setIsAuthenticated] = useState(false);
        const [user, setUser] = useState(null);
        const [loading, setLoading] = useState(true);

        useEffect(() => {
            try {
                const savedUser = localStorage.getItem('user');
                if (savedUser) {
                    const parsedUser = JSON.parse(savedUser);
                    setUser(parsedUser);
                    setIsAuthenticated(true);
                }
            } catch (error) {
                console.error('Error loading user from localStorage:', error);
                localStorage.removeItem('user');
            } finally {
                setLoading(false);
            }
        }, []);

        const login = (userData) => {
            localStorage.setItem('user', JSON.stringify(userData));
            setUser(userData);
            setIsAuthenticated(true);
        };

        const logout = () => {
            localStorage.removeItem('user');
            setUser(null);
            setIsAuthenticated(false);
        };

        return (
            <AuthContext.Provider value={{ 
                isAuthenticated, user, login, logout, updateUser, loading 
            }}>
                {children}
            </AuthContext.Provider>
        );
    };

    export const useAuth = () => {
        const context = useContext(AuthContext);
        if (!context) {
            throw new Error('useAuth must be used within an AuthProvider');
        }
        return context;
    };

Key features:
- Session persistence across browser refreshes via localStorage
- Centralized authentication state accessible from any component
- Loading state to prevent flash of unauthenticated content
- Clean separation of authentication logic from UI components

--------------------------------------------------------------------------------
4.1.3 Sign Up Page
--------------------------------------------------------------------------------

(See Figure X - Sign Up Page Screenshot)

The Sign Up page allows new users to create accounts with comprehensive
validation. Users can register as either "Users" (role=2) or "Suppliers"
(role=3).

Purpose: Enable new user registration with role selection

User Interaction Flow:
1. User enters personal information (name, email, phone, password)
2. User selects role (Users or Suppliers)
3. User submits form
4. System validates input and creates account
5. User is redirected to Sign In page upon success

State Management:
    const [formData, setFormData] = useState({
        user_name: '',
        email_address: '',
        phone_number: '',
        password: '',
        repassword: '',
        age: '',
        gender: '',
        city: '',
        role: 2  // Default to Users (2=Users, 3=Suppliers)
    });
    const [showPassword, setShowPassword] = useState(false);
    const [message, setMessage] = useState('');

Key Validation Logic:
    const handleSubmit = async (e) => {
        e.preventDefault();

        // Password match validation
        if (formData.password !== formData.repassword) {
            setMessage("Passwords do not match.");
            return;
        }

        // Age validation (0-122)
        if (formData.age.trim() === "" || !validateAge(formData.age)) {
            setMessage("Please enter a valid age (0-122).");
            return;
        }

        // Name length validation (2-50 characters)
        if (formData.user_name.trim().length < 2 || 
            formData.user_name.trim().length > 50) {
            setMessage("Your name must be between 2 and 50 characters.");
            return;
        }

        // Phone number validation (10 digits)
        if (!/^\d{10}$/.test(formData.phone_number)) {
            setMessage("Phone number must be 10 digits.");
            return;
        }

        // Password strength validation
        const passwordRegex = /^(?=.*[A-Z])(?=.*[!@#$%^&*(),.?":{}|<>])
            [A-Za-z\d!@#$%^&*(),.?":{}|<>]{8,}$/;
        if (!passwordRegex.test(formData.password)) {
            setMessage("Password must be at least 8 characters, include 
                one uppercase letter and one special character.");
            return;
        }

        // API call to register
        try {
            const response = await axios.post(
                'http://localhost:8000/postRegister/', 
                formData
            );
            setMessage('Registration successful! Please sign in.');
            setTimeout(() => navigate('/SignIn'), 2000);
        } catch (error) {
            setMessage(error.response?.data?.message || 
                'Cannot register at the moment.');
        }
    };

API Communication:
- POST /postRegister/ - Creates new user account
- Request body includes all form fields including role selection

--------------------------------------------------------------------------------
4.1.4 Sign In Page
--------------------------------------------------------------------------------

(See Figure X - Sign In Page Screenshot)

The Sign In page handles user authentication supporting both email and phone
number login.

Purpose: Authenticate existing users and establish session

User Interaction Flow:
1. User enters email/phone and password
2. User submits form
3. System validates credentials with backend
4. Upon success, user data is stored in AuthContext
5. User is redirected to Home page

Key Implementation:
    const SignIn = () => {
        const [formData, setFormData] = useState({
            phone_number_or_email: '',
            password: '',
        });
        const [message, setMessage] = useState('');
        const navigate = useNavigate();
        const { login } = useAuth();

        const handleSubmit = async (e) => {
            e.preventDefault();

            if (!formData.phone_number_or_email || !formData.password) {
                setMessage('Please enter both username/email and password.');
                return;
            }

            try {
                const response = await axios.post(
                    'http://localhost:8000/login', 
                    formData
                );
                setMessage('Login successful!');
                login(response.data.user);  // Store in AuthContext
                navigate('/');
            } catch (error) {
                setMessage(
                    error.response?.data?.detail || 
                    'Login failed. Please check your credentials.'
                );
            }
        };
    };

API Communication:
- POST /login - Authenticates user credentials
- Returns user object on success (including role and status)

--------------------------------------------------------------------------------
4.1.5 Home Page
--------------------------------------------------------------------------------

(See Figure X - Home Page Screenshot)

The Home Page serves as the primary landing page displaying promotional
content and product categories.

Purpose: Display product categories, promotions, and featured products

Key Features:
1. Auto-sliding promotional image carousel
2. Static promotional cards
3. Dynamic product carousels organized by category

State Management:
    const HomePage = () => {
        const { isAuthenticated, user } = useAuth();
        const [randomCategoriesWithProducts, setRandomCategoriesWithProducts] = 
            useState([]);
        const [listOfAllMainCategory, setListOfAllMainCategory] = useState([]);
        const [originalProducts, setOriginalProducts] = useState({});
        const [loading, setLoading] = useState(true);
        const [startSlider, setStartSlider] = useState(-100);
        const imgItemRef = useRef(null);
    };

Data Fetching:
    useEffect(() => {
        const fetchData = async () => {
            try {
                setLoading(true);
                // Fetch categories
                const categoriesResponse = await axios.get(
                    "http://127.0.0.1:8000/getAllCategory/"
                );
                if (categoriesResponse.status === 200) {
                    setListOfAllMainCategory(categoriesResponse.data.categories);
                }

                // Fetch all products
                const productsResponse = await axios.get(
                    "http://127.0.0.1:8000/getAllProduct/"
                );
                if (productsResponse.status === 200) {
                    setOriginalProducts(productsResponse.data);
                }
            } catch (error) {
                console.error("Error fetching data:", error);
            } finally {
                setLoading(false);
            }
        };
        fetchData();
    }, []);

Auto-Sliding Carousel Implementation:
    useEffect(() => {
        const timer = setTimeout(() => slideRight(), 3000);
        return () => clearTimeout(timer);
    }, [startSlider]);

    const slideRight = () => {
        setStartSlider((prev) => (prev === -600 ? -100 : prev - 100));
    };

    const slideLeft = () => {
        setStartSlider((prev) => (prev === -100 ? -600 : prev + 100));
    };

API Communication:
- GET /getAllCategory/ - Fetches distinct product categories
- GET /getAllProduct/ - Fetches products grouped by category

--------------------------------------------------------------------------------
4.1.6 Product Page
--------------------------------------------------------------------------------

(See Figure X - Product Page Screenshot)

The Product page displays a filterable, paginated list of products with
optional category filtering and rating-based filtering.

Purpose: Browse products by category with filtering and pagination

Key Features:
1. Category-based product filtering (via URL parameter)
2. Rating-based filtering (1-4+ stars)
3. Pagination (50 products per page)
4. Add to cart functionality

State Management:
    const Product = () => {
        const { category } = useParams();
        const [products, setProducts] = useState([]);
        const [currentPage, setCurrentPage] = useState(1);
        const [productsPerPage] = useState(50);
        const [ratingFilter, setRatingFilter] = useState(0);
        const [isLoading, setIsLoading] = useState(true);
    };

Category Mapping:
    const categoryNameMapping = {
        "0": "Accessories", "1": "Appliances", "2": "Bags & Luggage",
        "3": "Beauty & Health", "4": "Car & Motorbike", 
        "5": "Grocery & Gourmet Foods", "6": "Home & Kitchen",
        "7": "Home, Kitchen, Pets", "8": "Industrial Supplies",
        "9": "Kids' Fashion", "10": "Men's Clothing", "11": "Men's Shoes",
        "12": "Music", "13": "Pet Supplies", "14": "Sports & Fitness",
        "15": "Stores", "16": "Toys & Baby Products", 
        "17": "TV, Audio & Cameras", "18": "Women's Clothing", 
        "19": "Women's Shoes"
    };

Product Fetching:
    useEffect(() => {
        const fetchProducts = async () => {
            setIsLoading(true);
            setCurrentPage(1);
            let response;

            if (category) {
                response = await fetch(
                    `http://127.0.0.1:8000/getProductbyCategory/` +
                    `?categoryencode=${category}`
                );
            } else {
                response = await fetch(
                    "http://127.0.0.1:8000/getAllProductsFlat/"
                );
            }

            const data = await response.json();
            setProducts(data.products || data);
            setIsLoading(false);
        };
        fetchProducts();
    }, [category]);

Rating Filter Logic:
    const filteredProducts = ratingFilter > 0
        ? products.filter(item => 
            Math.floor(item.average_rating || 0) >= ratingFilter)
        : products;

Add to Cart Handler:
    const HandleAddToCart = async (item) => {
        if (!isAuthenticated || !user?.email_address) {
            toast.info("Please log in to add items to the cart.");
            navigate('/SignIn', {
                state: { from: location.pathname, itemToAdd: item }
            });
            return;
        }

        Dispatch(AddToCart(item));  // Redux action

        const response = await axios.post("http://localhost:8000/addToCart/", {
            product_id: (item.product_id || item.id),
            user_email: userInfo.email,
            quantity: 1
        });

        if (response.status === 200) {
            toast.success('Added to cart successfully');
            window.dispatchEvent(new Event('cartUpdated'));
        }
    };

API Communication:
- GET /getProductbyCategory/?categoryencode={id} - Products by category
- GET /getAllProductsFlat/ - All products as flat list
- POST /addToCart/ - Add product to user's cart

--------------------------------------------------------------------------------
4.1.7 Item Detail Page
--------------------------------------------------------------------------------

(See Figure X - Item Detail Page Screenshot)

The Item page displays detailed information for a single product with
related product recommendations.

Purpose: Display product details and similar product recommendations

Key Features:
1. Full product information display
2. Add to cart functionality
3. Related products section (ML-powered recommendations)

State Management:
    const Item = () => {
        const { product_id } = useParams();
        const [product, setProduct] = useState(null);
        const [relaProducts, setRelaProducts] = useState([]);
        const [loading, setLoading] = useState(true);
    };

Data Fetching:
    useEffect(() => {
        // Fetch product details
        fetch(`http://localhost:8000/Item/${product_id}`)
            .then((response) => response.json())
            .then((data) => setProduct(data[0]))
            .finally(() => setLoading(false));

        // Fetch related products (ML recommendation)
        fetch(`http://localhost:8000/RelatedItem/${product_id}`)
            .then((response) => response.json())
            .then((data) => setRelaProducts(data.products));
    }, [product_id]);

API Communication:
- GET /Item/{product_id} - Fetch single product details
- GET /RelatedItem/{product_id} - ML-based similar products

--------------------------------------------------------------------------------
4.1.8 Search Result Page
--------------------------------------------------------------------------------

(See Figure X - Search Result Page Screenshot)

The Search Result page displays products matching the user's search query,
powered by TF-IDF semantic search.

Purpose: Display search results with semantic matching

Implementation:
    const SearchResult = () => {
        const [SearchParams] = useSearchParams();
        const [products, setProducts] = useState([]);
        const [searchTerm, setSearchTerm] = useState('');

        useEffect(() => {
            const searchTermFromParams = SearchParams.get("searchTerm") || '';
            setSearchTerm(searchTermFromParams);

            fetch(`http://localhost:8000/products/search?` +
                `query=${encodeURIComponent(searchTermFromParams)}`)
                .then((response) => response.json())
                .then((data) => setProducts(data.products || []));
        }, [SearchParams]);
    };

API Communication:
- GET /products/search?query={term} - TF-IDF powered search

--------------------------------------------------------------------------------
4.1.9 Cart Page
--------------------------------------------------------------------------------

(See Figure X - Cart Page Screenshot)

The Cart page manages shopping cart items with quantity controls and
item selection for checkout.

Purpose: Display and manage cart items before checkout

Key Features:
1. Item quantity adjustment
2. Item removal
3. Selective checkout (item selection persists in localStorage)
4. Related product recommendations

State Management:
    const Cart = () => {
        const [CartItem, SetCartItem] = useState([]);
        const [selectedItems, setSelectedItems] = useState(new Set());
        const [isSelectionLoaded, setIsSelectionLoaded] = useState(false);
    };

Cart Operations:
    // Fetch cart items
    const fetchCartItems = async () => {
        const response = await axios.post("http://localhost:8000/cart", { 
            type: "display", 
            user_email: userInfo.email 
        });
        SetCartItem(response.data.cart);
    };

    // Update quantity
    const handleQuantityChange = async (id, newQuantity) => {
        if (newQuantity < 1) {
            toast.warn("Quantity cannot be less than 1.");
            return;
        }

        await axios.post("http://localhost:8000/cart", {
            type: "update-quantity",
            user_email: userInfo.email,
            product_id: id,
            quantity: newQuantity
        });

        Dispatch(UpdateCartQuantity(id, newQuantity));
        window.dispatchEvent(new Event('cartUpdated'));
    };

    // Remove item
    const handleDeleteItem = async (id) => {
        await axios.post("http://localhost:8000/cart", {
            type: "remove",
            user_email: userInfo.email,
            product_id: id
        });
        fetchCartItems();
    };

Selection Persistence:
    // Load selection from localStorage
    useEffect(() => {
        if (CartItem.length > 0 && userInfo.email) {
            const storageKey = `cartSelection_${userInfo.email}`;
            const savedSelection = localStorage.getItem(storageKey);
            if (savedSelection) {
                const parsed = JSON.parse(savedSelection);
                setSelectedItems(new Set(parsed));
            }
            setIsSelectionLoaded(true);
        }
    }, [CartItem, userInfo.email]);

    // Save selection to localStorage
    useEffect(() => {
        if (userInfo.email && isSelectionLoaded) {
            const storageKey = `cartSelection_${userInfo.email}`;
            localStorage.setItem(storageKey, 
                JSON.stringify(Array.from(selectedItems)));
        }
    }, [selectedItems, userInfo.email, isSelectionLoaded]);

API Communication:
- POST /cart {type: "display"} - Get cart items
- POST /cart {type: "update-quantity"} - Update item quantity
- POST /cart {type: "remove"} - Remove item
- POST /cartRelatedItems - Get association-based recommendations

--------------------------------------------------------------------------------
4.1.10 Checkout Page
--------------------------------------------------------------------------------

(See Figure X - Checkout Page Screenshot)

The Checkout page handles payment and shipping method selection with
order creation.

Purpose: Complete order with payment and shipping selection

State Management:
    const Checkout = () => {
        const [paymentMethods, setPaymentMethods] = useState([]);
        const [shippingMethods, setShippingMethods] = useState([]);
        const [selectedPaymentMethod, setSelectedPaymentMethod] = useState(null);
        const [selectedShippingMethod, setSelectedShippingMethod] = useState(null);
        const [isSubmitting, setIsSubmitting] = useState(false);
    };

Order Creation:
    const HandleProceed = async () => {
        if (selectedItems.length === 0) {
            toast.warn("No items selected for checkout.");
            return;
        }

        setIsSubmitting(true);

        const orderItems = selectedItems.map(item => ({
            product_id: item.product_id || item.id,
            quantity: item.quantity || 1,
            price: parseFloat(item.discount_price_usd) || 0
        }));

        const orderResponse = await axios.post(
            "http://localhost:8000/api/create-order", 
            {
                user_email: userInfo.email,
                payment_method_id: selectedPaymentMethod,
                shipping_method_id: selectedShippingMethod,
                items: orderItems
            }
        );

        if (orderResponse.data.order_id) {
            // Clear cart after successful order
            await axios.post("http://localhost:8000/cart", {
                type: "remove-all",
                user_email: userInfo.email
            });
            Dispatch(ClearCart());
            toast.success(`Order #${orderResponse.data.order_id} placed!`);
            setTimeout(() => navigate('/'), 2000);
        }
    };

API Communication:
- GET /api/payment-methods - Available payment methods
- GET /api/shipping-methods - Available shipping methods
- POST /api/create-order - Create new order

--------------------------------------------------------------------------------
4.1.11 Order History Page
--------------------------------------------------------------------------------

(See Figure X - Order History Page Screenshot)

The Order page displays user's order history with filtering and
order management capabilities.

Purpose: View order history with status filtering

Key Features:
1. Status-based filtering (Pending, Processing, Shipped, Delivered, etc.)
2. Time period filtering (30 days, 3 months, year)
3. Search functionality
4. Cancel orders (Pending only)
5. Return orders (Delivered only)

State Management:
    const Order = () => {
        const [orders, setOrders] = useState([]);
        const [filteredOrders, setFilteredOrders] = useState([]);
        const [activeTab, setActiveTab] = useState('Order');
        const [timePeriod, setTimePeriod] = useState('past3months');
        const [searchQuery, setSearchQuery] = useState('');
    };

Status Mapping:
    const statusMapping = {
        1: 'Pending',
        2: 'Processing',
        3: 'Shipped',
        4: 'Delivered',
        5: 'Cancelled',
        6: 'Returned'
    };

Order Cancellation:
    const confirmCancelOrder = async () => {
        const response = await axios.post('http://localhost:8000/order/cancel', {
            order_id: orderToCancel,
            user_email: user.email_address
        });
        if (response.data.message) {
            fetchOrders();  // Refresh order list
        }
    };

Order Return:
    const confirmReturnOrder = async () => {
        const response = await axios.post('http://localhost:8000/order/return', {
            order_id: orderToReturn,
            user_email: user.email_address
        });
        if (response.data.message) {
            fetchOrders();
        }
    };

API Communication:
- POST /order/history - Fetch user's order history
- POST /order/cancel - Cancel pending order
- POST /order/return - Return delivered order

--------------------------------------------------------------------------------
4.1.12 User Profile Page
--------------------------------------------------------------------------------

(See Figure X - User Profile Page Screenshot)

The User Page displays and allows editing of user profile information.

Purpose: View and manage user profile

Implementation:
    const UserPage = () => {
        const { isAuthenticated, user } = useAuth();
        const [userInfo, setUserInfo] = useState(null);
        const [loading, setLoading] = useState(true);

        useEffect(() => {
            if (!isAuthenticated || !user) {
                navigate('/SignIn');
                return;
            }

            const fetchUserInfo = async () => {
                const response = await axios.get(
                    "http://127.0.0.1:8000/getUserProfile/", 
                    { params: { email: user.email_address } }
                );
                if (response.status === 200) {
                    setUserInfo(response.data.data);
                }
            };
            fetchUserInfo();
        }, [isAuthenticated, user, navigate]);
    };

Displayed Information:
- Full Name, Email, Phone
- Age, Gender, City
- Address details (unit, street, address lines, region, postal code)

API Communication:
- GET /getUserProfile/?email={email} - Fetch user profile
- POST /postUpdate - Update user information

--------------------------------------------------------------------------------
4.1.13 Admin Overview Page
--------------------------------------------------------------------------------

(See Figure X - Admin Overview Page Screenshot)

The Admin Overview page provides system management capabilities including
statistics, user management, product management, and order management.

Purpose: Administrative dashboard for system management

Access Control:
    if (!isAuthenticated) {
        return <p>Please sign in to access this page.</p>;
    }
    if (user?.role !== 1) {
        return <p>You do not have permission to access this page.</p>;
    }

Tab Navigation:
    const tabs = [
        'Overview',
        'Customer Management',
        'Supplier Management',
        'Delivery Person Management',
        'Product Management',
        'Order Management',
        'Sales Analytics'
    ];

Statistics Display:
    const [stats, setStats] = useState({
        total_customers: 0,
        total_orders: 0,
        orders_today: 0,
        total_revenue: 0,
        revenue_today: 0,
        revenue_this_week: 0,
        revenue_this_month: 0,
        new_customers_today: 0,
        active_users_today: 0,
        users_ordered_today: 0
    });

Auto-Refresh Feature:
    useEffect(() => {
        let intervalId;
        if (autoRefresh && isAuthenticated && user?.role === 1) {
            intervalId = setInterval(() => refreshAll(), 30000);
        }
        return () => { if (intervalId) clearInterval(intervalId); };
    }, [autoRefresh, isAuthenticated, user?.role, refreshAll]);

API Communication:
- GET /admin/stats - Dashboard statistics
- GET /admin/order-status-counts - Order counts by status
- GET /admin/trending-products - Top products by rating
- GET /admin/orders - Paginated order list
- GET /admin/users - User management list


================================================================================
                      4.2 BACK-END IMPLEMENTATION
================================================================================

The backend is implemented using FastAPI with SQLAlchemy ORM for PostgreSQL
database operations. The system uses bcrypt for password hashing and includes
comprehensive validation and error handling.

--------------------------------------------------------------------------------
4.2.1 Application Configuration
--------------------------------------------------------------------------------

The FastAPI application is configured with CORS middleware:

    from fastapi import FastAPI
    from fastapi.middleware.cors import CORSMiddleware

    app = FastAPI()

    origins = ["http://localhost:3000"]
    app.add_middleware(
        CORSMiddleware,
        allow_origins=origins,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

Database Session Dependency:
    def get_db():
        db = SessionLocal()
        try:
            yield db
        finally:
            db.close()

--------------------------------------------------------------------------------
4.2.2 Authentication and Registration
--------------------------------------------------------------------------------

Password Hashing:
    from passlib.context import CryptContext
    pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

    def hash_password(password: str) -> str:
        return pwd_context.hash(password)

    def verify_password(plain_password: str, hashed_password: str) -> bool:
        return pwd_context.verify(plain_password, hashed_password)

User Registration (/postRegister/):
    @app.post("/postRegister/")
    async def postRegister(user: UserRegisterRequest, db: Session = Depends(get_db)):
        # Check for duplicate email
        existing_email = db.query(SiteUser).filter(
            SiteUser.email_address == user.email_address
        ).first()
        if existing_email:
            raise HTTPException(status_code=400, 
                detail="Email này đã được sử dụng.")
        
        # Check for duplicate phone
        existing_phone = db.query(SiteUser).filter(
            SiteUser.phone_number == user.phone_number
        ).first()
        if existing_phone:
            raise HTTPException(status_code=400, 
                detail="Số điện thoại này đã được sử dụng.")

        hashed_password = hash_password(user.password)

        db_user = SiteUser(
            user_name=user.user_name,
            age=user.age,
            gender=user.gender,
            email_address=user.email_address,
            phone_number=user.phone_number,
            city=user.city,
            password=hashed_password,
            role=user.role,  # 2=Users, 3=Suppliers
        )
        
        db.add(db_user)
        db.commit()
        db.refresh(db_user)

        return {
            "message": "Registration successful",
            "user": {...}
        }

User Login (/login):
    @app.post("/login")
    async def login(user: LoginRequire, db: Session = Depends(get_db)):
        # Determine if input is email or phone
        if is_email(user.phone_number_or_email):
            existing_user = db.query(SiteUser).filter(
                SiteUser.email_address == user.phone_number_or_email
            ).first()
        else:
            existing_user = db.query(SiteUser).filter(
                SiteUser.phone_number == user.phone_number_or_email
            ).first()

        if not existing_user:
            raise HTTPException(status_code=400, detail="User not found")

        if not verify_password(user.password, existing_user.password):
            raise HTTPException(status_code=401, detail="Invalid credentials")

        # Check account status
        user_status = (existing_user.status or 'active').lower()
        if user_status == 'locked':
            raise HTTPException(status_code=403,
                detail="Your account has been locked.")
        elif user_status == 'disabled':
            raise HTTPException(status_code=403,
                detail="Your account has been disabled.")

        # Update last login timestamp
        existing_user.last_login_at = datetime.utcnow()
        db.commit()

        return {"message": "Login successful", "user": user_response}

Account Status Verification:
    async def verify_active_user(user_email: str, db: Session):
        user = db.query(SiteUser).filter(
            SiteUser.email_address == user_email
        ).first()
        
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        
        user_status = (user.status or 'active').lower()
        if user_status == 'locked':
            raise HTTPException(status_code=403,
                detail="Your account has been locked.")
        elif user_status == 'disabled':
            raise HTTPException(status_code=403,
                detail="Your account has been disabled.")

--------------------------------------------------------------------------------
4.2.3 Product Management
--------------------------------------------------------------------------------

Get All Products (/getAllProduct/):
    @app.get("/getAllProduct/")
    async def get_all_products(db: Session = Depends(get_db)):
        all_products = db.query(Product).all()
        
        grouped_products_by_category = defaultdict(list)
        for product in all_products:
            grouped_products_by_category[product.main_category].append(product)

        result = {}
        for main_category, products in grouped_products_by_category.items():
            sorted_products = sorted(
                products, 
                key=lambda p: (p.no_of_ratings, p.average_rating), 
                reverse=True
            )
            result[main_category] = [
                {...} for product in sorted_products[:20]
            ]
        return result

Search Products (/products/search):
    @app.get("/products/search", response_model=ProductResponse)
    async def search_products(query: str = "", db: Session = Depends(get_db)):
        # Uses TF-IDF recommendation system
        product_ids = get_search_recommendations(query)
        
        products = db.query(Product).filter(
            Product.product_id.in_(product_ids)
        ).all()

        if not products:
            return JSONResponse(status_code=404, 
                content={"message": "No products found."})
        
        return {"products": products}

Related Items (/RelatedItem/{product_id}):
    @app.get("/RelatedItem/{product_id}")
    async def related_item(product_id: str, db: Session = Depends(get_db)):
        # Uses item-based recommendation
        product_ids = get_item_recommendation(product_id)
        
        products = db.query(Product).filter(
            Product.product_id.in_(product_ids)
        ).all()
        
        return {"products": products}

--------------------------------------------------------------------------------
4.2.4 Shopping Cart
--------------------------------------------------------------------------------

Cart Operations (/cart):
    @app.post("/cart")
    async def handle_cart(request: CartFetch, db: Session = Depends(get_db)):
        await verify_active_user(request.user_email, db)
        
        user = db.query(SiteUser).filter(
            SiteUser.email_address == request.user_email
        ).first()

        cart = db.query(ShoppingCart).filter(
            ShoppingCart.user_id == user.user_id
        ).first()

        if request.type == "display":
            cart_items = (
                db.query(ShoppingCartItem, Product)
                .join(Product, ShoppingCartItem.product_id == Product.product_id)
                .filter(ShoppingCartItem.shopping_cart_id == cart.shopping_cart_id)
                .all()
            )
            return {"cart": [...]}

        elif request.type == "remove":
            cart_item = db.query(ShoppingCartItem).filter(
                ShoppingCartItem.shopping_cart_id == cart.shopping_cart_id,
                ShoppingCartItem.product_id == request.product_id
            ).first()
            db.delete(cart_item)
            db.commit()
            return {"message": f"Product removed from cart."}

        elif request.type == "update-quantity":
            cart_item.quantity = request.quantity
            db.commit()
            return {"message": "Quantity updated successfully"}

        elif request.type == "remove-all":
            db.query(ShoppingCartItem).filter(
                ShoppingCartItem.shopping_cart_id == cart.shopping_cart_id
            ).delete()
            db.commit()
            return {"message": "All items removed from cart."}

Add to Cart (/addToCart/):
    @app.post("/addToCart/")
    async def add_to_cart(request: AddToCartRequest, db: Session = Depends(get_db)):
        await verify_active_user(request.user_email, db)
        
        # Get or create cart
        cart = db.query(ShoppingCart).filter(
            ShoppingCart.user_id == user.user_id
        ).first()
        if not cart:
            cart = ShoppingCart(user_id=user.user_id)
            db.add(cart)
            db.commit()

        # Check for existing item
        cart_item = db.query(ShoppingCartItem).filter(
            ShoppingCartItem.shopping_cart_id == cart.shopping_cart_id,
            ShoppingCartItem.product_id == product.product_id
        ).first()

        if cart_item:
            cart_item.quantity += request.quantity
        else:
            new_cart_item = ShoppingCartItem(
                shopping_cart_id=cart.shopping_cart_id,
                product_id=product.product_id,
                quantity=request.quantity,
                price=product.discount_price_usd
            )
            db.add(new_cart_item)

        db.commit()
        return {"message": "Product added to cart successfully"}

--------------------------------------------------------------------------------
4.2.5 Order Processing
--------------------------------------------------------------------------------

Create Order (/api/create-order):
    @app.post("/api/create-order")
    async def create_order_api(request: CreateOrderRequest, 
                               db: Session = Depends(get_db)):
        await verify_active_user(request.user_email, db)

        # Validate payment and shipping methods
        payment_method = db.query(PaymentType).filter(
            PaymentType.payment_type_id == request.payment_method_id
        ).first()
        shipping_method = db.query(ShippingMethod).filter(
            ShippingMethod.shipping_method_id == request.shipping_method_id
        ).first()

        # Calculate totals
        items_total = sum(item.quantity * item.price for item in request.items)
        shipping_cost = float(shipping_method.price)
        order_total = items_total + shipping_cost

        # Create order
        new_order = ShopOrder(
            user_id=user.user_id,
            order_date=datetime.now().date(),
            order_total=order_total,
            payment_method_id=request.payment_method_id,
            shipping_method_id=request.shipping_method_id,
            order_status_id=1,  # Pending
        )
        db.add(new_order)
        db.commit()

        # Create order lines
        for item in request.items:
            order_line = OrderLine(
                order_id=new_order.order_id,
                product_id=item.product_id,
                qty=item.quantity,
                price=item.price,
            )
            db.add(order_line)

        db.commit()
        return {"order_id": new_order.order_id, "order_total": order_total}

Cancel Order (/order/cancel):
    @app.post("/order/cancel")
    async def cancel_order(order_id: int, user_email: str, 
                          db: Session = Depends(get_db)):
        # Verify ownership and status
        if order.order_status_id != 1:  # Only Pending
            raise HTTPException(status_code=400,
                detail="Only Pending orders can be cancelled")

        order.order_status_id = 5  # Cancelled
        order.completed_at = datetime.utcnow()
        db.commit()
        return {"message": "Order cancelled successfully"}

Return Order (/order/return):
    @app.post("/order/return")
    async def return_order(order_id: int, user_email: str,
                          db: Session = Depends(get_db)):
        # Only Delivered orders can be returned
        if order.order_status_id != 4:
            raise HTTPException(status_code=400,
                detail="Only Delivered orders can be returned")

        order.order_status_id = 6  # Returned
        db.commit()
        return {"message": "Order return requested successfully"}

--------------------------------------------------------------------------------
4.2.6 Admin APIs
--------------------------------------------------------------------------------

Admin Statistics (/admin/stats):
    @app.get("/admin/stats")
    async def get_admin_stats(db: Session = Depends(get_db)):
        today = datetime.now().date()
        
        total_customers = db.query(SiteUser).filter(
            SiteUser.role == 2
        ).count()
        
        total_orders = db.query(ShopOrder).count()
        
        delivered_orders = db.query(ShopOrder).filter(
            ShopOrder.order_status_id == 4
        ).all()
        total_revenue = sum(float(order.order_total or 0) 
            for order in delivered_orders)

        return {
            "total_customers": total_customers,
            "total_orders": total_orders,
            "orders_today": orders_today,
            "total_revenue": round(total_revenue, 2),
        }

Bulk Status Update (/admin/orders/bulk-status):
    @app.put("/admin/orders/bulk-status")
    async def update_bulk_order_status(bulk_update: dict, 
                                       db: Session = Depends(get_db)):
        # Security: Admins cannot set Returned status
        if status_id == 6:
            raise HTTPException(status_code=403,
                detail="Returned status can only be initiated by customer")

        final_states = [4, 5, 6]  # Delivered, Cancelled, Returned
        
        for order_id in order_ids:
            order = db.query(ShopOrder).filter(
                ShopOrder.order_id == order_id
            ).first()
            
            if order.order_status_id not in final_states:
                order.order_status_id = status_id
                if status_id in [4, 5]:
                    order.completed_at = datetime.now()

        db.commit()


================================================================================
              4.3 AI / MACHINE LEARNING IMPLEMENTATION
================================================================================

The ML recommendation system uses multiple algorithms implemented in Python
with scikit-learn and pandas, connecting to MongoDB for user and product data.

--------------------------------------------------------------------------------
4.3.1 System Architecture
--------------------------------------------------------------------------------

The ML module (recommend.py) connects to MongoDB:

    from pymongo.mongo_client import MongoClient
    import pandas as pd

    MONGODB_URI = "mongodb+srv://..."
    client = MongoClient(MONGODB_URI)

    db = client["SmartOnlineMarketplaceWebsite"]
    user_collection = db["new_user_data"]
    rating_collection = db["new_rating"]
    product_collection = db["new_product"]
    association_collection = db["association_rules"]
    interest_collection = db["new_user_interests"]

    # Load data into pandas DataFrames
    user_df = pd.DataFrame(list(user_collection.find()))
    rating_df = pd.DataFrame(list(rating_collection.find()))
    product_df = pd.DataFrame(list(product_collection.find()))
    association_df = pd.DataFrame(list(association_collection.find()))

--------------------------------------------------------------------------------
4.3.2 TF-IDF Search Recommendation
--------------------------------------------------------------------------------

The SearchRecommendation class uses TF-IDF vectorization:

    from sklearn.feature_extraction.text import TfidfVectorizer
    from sklearn.metrics.pairwise import cosine_similarity

    class SearchRecommendation:
        def __init__(self, product):
            self.product = product
            self.product['processed_name'] = self.product['name'].str.lower()
            self.vectorizer = TfidfVectorizer(stop_words='english')
            self.tfidf_matrix = self.vectorizer.fit_transform(
                self.product['processed_name']
            )

        def search(self, query, top_n=40):
            query_vector = self.vectorizer.transform([query.lower()])
            cosine_similarities = cosine_similarity(
                query_vector, 
                self.tfidf_matrix
            ).flatten()
            
            results_df = pd.DataFrame({
                'id': self.product['id'].astype(str),
                'name': self.product['name'],
                'cosine_similarity': cosine_similarities
            })
            results_df = results_df.sort_values(
                by='cosine_similarity', 
                ascending=False
            )
            return results_df['id'].head(top_n).tolist()

Algorithm Explanation:
- TF-IDF (Term Frequency-Inverse Document Frequency) converts product names
  to numerical vectors
- Cosine similarity measures angle between query and product vectors
- Higher similarity indicates more relevant products
- Stop words (common words like "the", "a") are removed

--------------------------------------------------------------------------------
4.3.3 Collaborative Filtering
--------------------------------------------------------------------------------

User-based collaborative filtering using demographic similarity:

    class CollabRecommendationModel:
        @staticmethod
        def calculate_similarity(user1, user2):
            # Gender similarity (binary: 0 or 1)
            gender_sim = 1 if user1['gender'] == user2['gender'] else 0
            
            # Age similarity (normalized)
            age_sim = 1 - abs(user1['age'] - user2['age']) / 100
            
            # Location similarity
            if user1['city'] == user2['city']:
                location_sim = 1
            else:
                location_sim = 0.5
            
            # Weighted combination (age weighted highest at 60%)
            total_similarity = (
                0.2 * gender_sim + 
                0.6 * age_sim + 
                0.2 * location_sim
            )
            return total_similarity

        def find_top_similar_users(self, user_info):
            similarities = []
            for _, other_user in self.user_data.iterrows():
                similarity = self.calculate_similarity(user_info, other_user)
                similarities.append((other_user['user_id'], similarity))
            
            similarities.sort(key=lambda x: x[1], reverse=True)
            return [user[0] for user in similarities[:50]]

        def collaborative_filtering_recommendations(self, user_id, user_info):
            top_similar_users = self.find_top_similar_users(user_info)
            
            # Create user-item matrix
            user_item_matrix = filtered_ratings.pivot_table(
                index='user_id',
                columns='productid',
                values='rating',
                aggfunc='mean'
            ).fillna(0)
            
            # Calculate user-user similarity using cosine
            user_similarity = cosine_similarity(user_item_matrix)
            
            # Find products rated by similar users
            recommended_items = set()
            for target_user_id in top_similar_users:
                # Get items rated by similar users but not by target
                ...
            
            return top_recommendations['productid'].tolist()

Algorithm Explanation:
- Finds users with similar demographics (age, gender, city)
- Age is weighted at 60% as it strongly correlates with preferences
- Creates user-item rating matrix
- Uses cosine similarity on rating patterns
- Recommends products liked by similar users

--------------------------------------------------------------------------------
4.3.4 Item-Based Similarity
--------------------------------------------------------------------------------

The ItemRecommendationModel finds similar products:

    class ItemRecommendationModel:
        def __init__(self, product):
            self.product = product
            self.product['processed_name'] = self.product['name'].str.lower()
            self.vectorizer = TfidfVectorizer(stop_words='english')
            self.tfidf_matrix = self.vectorizer.fit_transform(
                self.product['processed_name']
            )

        def find_similar_items(self, item_id, top_n=20):
            if item_id not in self.product['id'].values:
                return []

            item_index = self.product[self.product['id'] == item_id].index[0]
            item_vector = self.tfidf_matrix[item_index]
            
            cosine_similarities = cosine_similarity(
                item_vector, 
                self.tfidf_matrix
            ).flatten()
            
            similar_indices = cosine_similarities.argsort()[-top_n - 1:-1][::-1]
            return self.product.iloc[similar_indices]['id'].tolist()

Usage: Related products on Item detail page

--------------------------------------------------------------------------------
4.3.5 Association Rules
--------------------------------------------------------------------------------

The AssociationRecommendationModel uses pre-computed association rules:

    class AssociationRecommendationModel:
        def __init__(self, product, rules):
            self.product = product
            self.rules = rules  # Pre-computed association rules

        def get_top_associated_categories(self, item_ids, n=3):
            top_associated_categories = set()

            for item_id in item_ids:
                item_info = self.product[self.product['id'] == item_id]
                item_category = (
                    f"{item_info.iloc[0]['main_category']} - " +
                    f"{item_info.iloc[0]['sub_category']}"
                )
                
                # Find rules where this category is antecedent
                relevant_rules = self.rules[
                    self.rules['antecedents'].apply(
                        lambda x: item_category in x
                    )
                ]
                
                # Sort by lift (association strength)
                relevant_rules = relevant_rules.sort_values(
                    by='lift', 
                    ascending=False
                ).head(n)
                
                # Extract associated categories
                for _, row in relevant_rules.iterrows():
                    for category_set in [row['antecedents'], row['consequents']]:
                        if isinstance(category_set, str):
                            for category in category_set.split(", "):
                                if category != item_category:
                                    top_associated_categories.add(category)
            
            return list(top_associated_categories)[:n]

        def get_top_rated_items(self, associated_categories, top_n=5):
            top_items = []
            for category in associated_categories:
                main_cat, sub_cat = category.split(" - ")
                category_items = self.product[
                    (self.product['main_category'] == main_cat) &
                    (self.product['sub_category'] == sub_cat)
                ]
                top_rated = category_items.sort_values(
                    by='ratings', 
                    ascending=False
                ).head(top_n)
                top_items.extend(top_rated['id'].tolist())
            return top_items

Usage: Cart page recommendations ("Customers also bought")

--------------------------------------------------------------------------------
4.3.6 Trending Products (Cold-Start Handling)
--------------------------------------------------------------------------------

For new users without history:

    class RecommendTrendModel:
        def most_trending_products(self, top_n=20):
            trending_products = self.product_data.sort_values(
                by=['ratings', 'no_of_ratings'], 
                ascending=False
            ).head(top_n)
            return trending_products['id'].tolist()

        def recommend(self, user_info, top_n=20):
            collaborative_recs = self.collaborative_filtering_recommendations(
                user_info, 
                top_n=top_n
            )
            trending_recs = self.most_trending_products(top_n=top_n)
            return collaborative_recs + trending_recs

This hybrid approach handles the cold-start problem by combining personalized
recommendations with globally popular products.


================================================================================
                  4.4 MODEL HOSTING AND DEPLOYMENT
================================================================================

--------------------------------------------------------------------------------
4.4.1 Docker Configuration
--------------------------------------------------------------------------------

The ML service is containerized using Docker:

    FROM python:3.10

    WORKDIR /ML_FastAPI_Docker_Heroku

    COPY ./requirements.txt /ML_FastAPI_Docker_Heroku/requirements.txt

    RUN pip install --no-cache-dir --upgrade -r \
        /ML_FastAPI_Docker_Heroku/requirements.txt

    COPY ./main.py /ML_FastAPI_Docker_Heroku/main.py
    COPY ./.env /ML_FastAPI_Docker_Heroku/.env

    EXPOSE 80

    CMD ["sh", "-c", "uvicorn main:app --host 0.0.0.0 --port ${PORT:-80}"]

Key Configuration Decisions:
1. Base Image: Python 3.10 for compatibility with ML libraries
2. --no-cache-dir: Reduces image size
3. Dynamic PORT: Supports cloud platform deployment
4. Uvicorn: Production-grade ASGI server

--------------------------------------------------------------------------------
4.4.2 FastAPI and Uvicorn Architecture
--------------------------------------------------------------------------------

FastAPI provides:
- Automatic OpenAPI documentation
- Request validation via Pydantic
- Async/await support for efficient I/O

Uvicorn provides:
- High-performance HTTP handling
- Multiple concurrent connections
- Production-ready deployment

--------------------------------------------------------------------------------
4.4.3 Cloud Deployment
--------------------------------------------------------------------------------

The service is designed for cloud platforms (Google Cloud Run, Heroku):

Scalability Features:
- Stateless design enables horizontal scaling
- Health check endpoint (/healthz) for load balancers
- Environment variables for configuration
- Container auto-scaling based on demand

Data Flow:
1. Backend server receives recommendation request
2. Backend invokes ML service via HTTP
3. ML service processes using pre-loaded models
4. ML service returns product IDs
5. Backend fetches product details from PostgreSQL
6. Combined response sent to frontend


================================================================================
                     4.5 TESTING AND VERIFICATION
================================================================================

During system analysis, the following terminal observations were made:

Frontend Terminal (npm start):
- React development server runs on port 3000
- No critical compilation errors
- Hot module replacement active

Backend Terminal (uvicorn main:app --reload):
- FastAPI server runs on port 8000
- Successfully connects to PostgreSQL database
- ML recommendation module loads without errors
- API requests logged with response times

System Stability:
- Authentication flows work correctly
- Product browsing and search function properly
- Cart operations execute without errors
- Order creation and management operate as expected
- Admin dashboard loads statistics correctly

No critical errors or warnings were observed during the analysis session.


================================================================================
                              SUMMARY
================================================================================

This implementation chapter has documented the Amazon Clone e-commerce system:

1. FRONTEND (React.js):
   - 13 major page components
   - Context-based state management (AuthContext)
   - Redux for cart state
   - Axios for API communication
   - localStorage for session persistence

2. BACKEND (FastAPI + PostgreSQL):
   - Bcrypt password hashing
   - Role-based access (Admin/User/Supplier)
   - Account status verification
   - Comprehensive cart and order management
   - Admin dashboard APIs

3. MACHINE LEARNING (Python + MongoDB):
   - TF-IDF search
   - Collaborative filtering
   - Item-based similarity
   - Association rules
   - Cold-start handling with trending products

4. DEPLOYMENT:
   - Docker containerization
   - FastAPI + Uvicorn
   - Cloud-ready architecture

The modular architecture enables independent development and scaling of each
component while maintaining clear interfaces between layers.

================================================================================
                          END OF CHAPTER 4
================================================================================
